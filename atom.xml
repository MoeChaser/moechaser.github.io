<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoeChaser&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://moechaser.github.io/"/>
  <updated>2018-08-02T15:59:44.021Z</updated>
  <id>https://moechaser.github.io/</id>
  
  <author>
    <name>MoeChaser</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单一职责原则</title>
    <link href="https://moechaser.github.io/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/"/>
    <id>https://moechaser.github.io/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/</id>
    <published>2018-08-02T15:35:31.000Z</published>
    <updated>2018-08-02T15:59:44.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change.）</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>只有一个原因引起变化，也就是一个接口或类只有一个职责，它只负责一件事情。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以电话为例，电话通话包括三个过程：拨号、通话、挂断。写一个接口如下图：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram1.png"><p>这个接口比较简单，大部分人也会认为没有问题。但实际上，这个接口不只有一个职责，实际上包含了两个职责：一个是协议管理，负责通信过程的连接和断开，即dial()和hangup()方法；另一个是数据传送，在通话过程中传输双方的对话，即chat()。协议管理的变化（例如更换运营商）会引起这个接口或实现类的变化，数据传送的变化（例如除了传输语音数据外，也可以传输网络数据）也会引起这个接口或实现类的变化。因此这里有两个原因引起了类的变化。<br>我们考虑将这个接口拆分成两个接口，如下图所示：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram2.png"><p>这个类图满足了单一职责原则的要求，每个接口职责分明。但是电话类需要把ConnectionManager和DataTransfer组合在一起才能使用，组合是一种强耦合关系，同时类的数量也增加了，实际上增加了设计的复杂性。因此我们修改类的设计如下图：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram3.png"><p>实现类实现了两个接口，在面向接口编程的原则下，接口的设计满足了单一职责原则，一个接口修改对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>单一职责原则最难划分的就是职责，一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？这些都需要从实际的项目去考虑。</li><li>从功能上来说，定义一个IPhone接口也没有错，实现了电话的功能，而且设计还很简单，仅仅一个接口一个实现类，实际的项目可能大家都会这么设计。项目要考虑可变因素和不可变因素，以及相关的收益成本比率，因此设计一个IPhone接口也可能是没有错的。只是从SRP的严格定义来分析就有问题了。</li><li>对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。原则是死的，人是活的。</li><li>单一职责适用于接口、类，同时也适用于方法。一个方法承担一个职责。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;应该有且仅有一个原因引起类的变更（There should never be more than one reason for a clas
      
    
    </summary>
    
      <category term="Technology" scheme="https://moechaser.github.io/categories/Technology/"/>
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/categories/Technology/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
</feed>
