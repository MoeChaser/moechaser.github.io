<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoeChaser&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://moechaser.github.io/"/>
  <updated>2018-08-24T15:22:06.939Z</updated>
  <id>https://moechaser.github.io/</id>
  
  <author>
    <name>MoeChaser</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>里氏替换原则</title>
    <link href="https://moechaser.github.io/Technology/Design-Pattern/2018/08/24/liskov-substitution-principle/"/>
    <id>https://moechaser.github.io/Technology/Design-Pattern/2018/08/24/liskov-substitution-principle/</id>
    <published>2018-08-23T16:12:53.000Z</published>
    <updated>2018-08-24T15:22:06.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>定义1：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。（If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.）</li><li>定义2：所有引用基类的地方必须能透明地使用其子类的对象。（Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.）</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>只要父类能出现的地方子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能不需要知道实际对象是父类还是子类。</p><a id="more"></a><p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p><ol><li>子类必须完全实现父类的方法<ul><li>子类需要完全实现父类的方法，只有这样，当通过父类或接口进行调用时，才不会产生异常。如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</li><li>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</li></ul></li><li>子类可以有自己的个性<ul><li>子类可以有自己的属性与方法，在特定场景中使用。</li><li>里氏替换原则强调的是在所有引用基类的地方必须能透明地使用其子类的对象。反过来却不一定可行，即在子类出现的地方，父类未必就可以胜任。</li></ul></li><li>覆盖或实现父类的方法时输入参数可以被放大<ul><li>这句话的意思是子类在定义父类中已经有的方法的时候，可以将方法参数类型改为可以表示更大范围的参数类型，仍然符合里氏替换原则。如父类方法的参数类型是HashMap，子类方法的参数类型是Map，Map表示的范围比HashMap更大，此时在引用父类的地方通过子类对象调用该方法，实际执行的是父类中定义的方法，符合里氏替换原则。子类的这种方法定义实际是重载（Overload），不是覆写（Override）。</li><li>如果子类方法的参数类型比父类方法的参数类型范围更小，则不符合里氏替换原则。例如，父类方法参数类型是Map，子类方法参数类型是HashMap，在引用父类的地方通过子类对象调用该方法，传入参数实际类型是HashMap，实际执行的是子类中定义的方法。然而子类的这个方法并没有覆写（Override）父类的方法（实际是重载），却在引用父类的地方被执行。其行为违反了上面的定义1，所以不符合里氏替换原则。</li></ul></li><li>覆写或实现父类的方法时输出结果可以被缩小<ul><li>子类在覆写或实现父类方法时，其声明的返回值类型的范围必须小于等于父类方法声明的返回值类型。例如，父类方法返回值类型是S，子类方法返回值类型是T，要么T与S是相同类型，要么T是S的子类。</li><li>如果子类方法的返回值类型比父类方法范围更大，则编译会报错，返回值类型不兼容。</li></ul></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>增强程序的健壮性，版本升级时也可以保持较好的兼容性。即使增加子类，原有的子类还可以继续运行；接口使用父类作为参数类型，无需改变接口即可扩展功能。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——子类的特殊场景不能满足使用要求；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。</li></ul><blockquote><p>本文是《设计模式之禅（第2版）》的读书笔记，文中的图示大多来自于本书，图片版权归原书作者所有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定义1：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。（If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.）&lt;/li&gt;
&lt;li&gt;定义2：所有引用基类的地方必须能透明地使用其子类的对象。（Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot; title=&quot;解释&quot;&gt;&lt;/a&gt;解释&lt;/h2&gt;&lt;p&gt;只要父类能出现的地方子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能不需要知道实际对象是父类还是子类。&lt;/p&gt;
    
    </summary>
    
      <category term="Technology" scheme="https://moechaser.github.io/categories/Technology/"/>
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/categories/Technology/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>单一职责原则</title>
    <link href="https://moechaser.github.io/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/"/>
    <id>https://moechaser.github.io/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/</id>
    <published>2018-08-02T15:35:31.000Z</published>
    <updated>2018-08-24T15:21:50.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change.）</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>只有一个原因引起变化，也就是一个接口或类只有一个职责，它只负责一件事情。</p><a id="more"></a><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以电话为例，电话通话包括三个过程：拨号、通话、挂断。写一个接口如下图：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram1.png"><p>这个接口比较简单，大部分人也会认为没有问题。但实际上，这个接口不只有一个职责，实际上包含了两个职责：一个是协议管理，负责通信过程的连接和断开，即dial()和hangup()方法；另一个是数据传送，在通话过程中传输双方的对话，即chat()。协议管理的变化（例如更换运营商）会引起这个接口或实现类的变化，数据传送的变化（例如除了传输语音数据外，也可以传输网络数据）也会引起这个接口或实现类的变化。因此这里有两个原因引起了类的变化。<br>我们考虑将这个接口拆分成两个接口，如下图所示：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram2.png"><p>这个类图满足了单一职责原则的要求，每个接口职责分明。但是电话类需要把ConnectionManager和DataTransfer组合在一起才能使用，组合是一种强耦合关系，同时类的数量也增加了，实际上增加了设计的复杂性。因此我们修改类的设计如下图：</p><img src="/Technology/Design-Pattern/2018/08/02/single-responsibility-principle/phone-class-diagram3.png"><p>实现类实现了两个接口，在面向接口编程的原则下，接口的设计满足了单一职责原则，一个接口修改对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>单一职责原则最难划分的就是职责，一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？这些都需要从实际的项目去考虑。</li><li>从功能上来说，定义一个IPhone接口也没有错，实现了电话的功能，而且设计还很简单，仅仅一个接口一个实现类，实际的项目可能大家都会这么设计。项目要考虑可变因素和不可变因素，以及相关的收益成本比率，因此设计一个IPhone接口也可能是没有错的。只是从SRP的严格定义来分析就有问题了。</li><li>对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。原则是死的，人是活的。</li><li>单一职责适用于接口、类，同时也适用于方法。一个方法承担一个职责。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</li></ul><blockquote><p>本文是《设计模式之禅（第2版）》的读书笔记，文中的图示大多来自于本书，图片版权归原书作者所有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change.）&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot; title=&quot;解释&quot;&gt;&lt;/a&gt;解释&lt;/h2&gt;&lt;p&gt;只有一个原因引起变化，也就是一个接口或类只有一个职责，它只负责一件事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Technology" scheme="https://moechaser.github.io/categories/Technology/"/>
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/categories/Technology/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://moechaser.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
</feed>
